# Generated by CodiumAI
import os
import sys
import unittest
from unittest import mock
from unittest.mock import Mock

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from lib.data import (
    get_project,
    get_projects,
    get_service,
    get_services,
    upsert_project,
)
from lib.models import Project, Service


class TestCodeUnderTest(unittest.TestCase):

    # Get all projects
    @mock.patch("builtins.open", new_callable=mock.mock_open)
    @mock.patch("yaml.safe_load")
    def test_get_all_projects_with_mock_imported(self, mock_safe_load: Mock, mock_open: Mock) -> None:

        # Mock the return value of yaml.safe_load
        mock_safe_load.return_value = {
            "projects": [
                {
                    "name": "project1",
                    "description": "description1",
                    "domain": "domain1",
                    "upstream": "upstream1",
                    "services": [],
                },
                {
                    "name": "project2",
                    "description": "description2",
                    "domain": "domain2",
                    "upstream": "upstream2",
                    "services": [],
                },
            ]
        }

        # Call the function under test
        result = get_projects()

        # Assert that the mock functions were called correctly
        mock_open.assert_called_once_with("db.yml", encoding="utf-8")

        # Assert the result
        expected_result = [
            Project(
                name="project1",
                description="description1",
                domain="domain1",
                upstream="upstream1",
                services=[],
            ),
            Project(
                name="project2",
                description="description2",
                domain="domain2",
                upstream="upstream2",
                services=[],
            ),
        ]
        self.assertEqual(result, expected_result)

    # Get a project by name with the recommended fix
    @mock.patch("lib.data.get_projects")
    def test_get_project_by_name_with_mock_imported_with_fix(self, mock_get_projects: Mock) -> None:

        # Mock the return value of get_projects
        mock_get_projects.return_value = [
            Project(
                name="project1",
                description="description1",
                domain="domain1",
                upstream="upstream1",
                services=[],
            ),
            Project(
                name="project2",
                description="description2",
                domain="domain2",
                upstream="upstream2",
                services=[],
            ),
        ]

        # Call the function under test
        result = get_project("project1")

        # Assert the result
        expected_result = Project(
            name="project1",
            description="description1",
            domain="domain1",
            upstream="upstream1",
            services=[],
        )
        self.assertEqual(result, expected_result)

    # Get all services with mock
    @mock.patch("lib.data.get_projects")
    def test_get_all_services_with_mock(self, mock_get_projects: Mock) -> None:
        # Mock the return value of get_projects
        mock_get_projects.return_value = [
            Project(
                name="project1",
                description="description1",
                domain="domain1",
                upstream="upstream1",
                services=[
                    Service(svc="service1", port=8080),
                    Service(svc="service2", port=8081),
                ],
            ),
            Project(
                name="project2",
                description="description2",
                domain="domain2",
                upstream="upstream2",
                services=[Service(svc="service3", port=8082)],
            ),
        ]

        # Call the function under test
        result = get_services()

        # Assert the result
        expected_result = [
            Service(svc="service1", port=8080, project="project1", domain="domain1"),
            Service(svc="service2", port=8081, project="project1", domain="domain1"),
            Service(svc="service3", port=8082, project="project2", domain="domain2"),
        ]
        self.assertEqual(result, expected_result)

    # Get a project by name that does not exist
    @mock.patch("lib.data.get_projects")
    def test_get_nonexistent_project_by_name(self, mock_get_projects: Mock) -> None:

        # Mock the return value of get_projects
        mock_get_projects.return_value = [
            Project(
                name="project1",
                description="description1",
                domain="domain1",
                upstream="upstream1",
                services=[],
            ),
            Project(
                name="project2",
                description="description2",
                domain="domain2",
                upstream="upstream2",
                services=[],
            ),
        ]

        # Call the function under test
        with self.assertRaises(ValueError):
            get_project("nonexistent_project")

    # Get a service by name that does not exist
    @mock.patch("lib.data.get_project")
    def test_get_nonexistent_service_by_name(self, mock_get_project: Mock) -> None:

        # Mock the return value of get_project
        mock_get_project.return_value = Project(
            name="project1",
            description="description1",
            domain="domain1",
            upstream="upstream1",
            services=[
                Service(svc="service1", port=8080),
                Service(svc="service2", port=8081),
            ],
        )

        # Call the function under test
        with self.assertRaises(ValueError):
            get_service("project1", "nonexistent_service")

    # Upsert a project that does not exist (Fixed)
    @mock.patch("lib.data.get_projects")
    @mock.patch("lib.data.write_projects")
    def test_upsert_nonexistent_project_fixed(self, mock_write_projects: Mock, mock_get_projects: Mock) -> None:

        # Mock the return value of get_projects
        mock_get_projects.return_value = [
            Project(
                name="project1",
                description="description1",
                domain="domain1",
                upstream="upstream1",
                services=[],
            ),
            Project(
                name="project2",
                description="description2",
                domain="domain2",
                upstream="upstream2",
                services=[],
            ),
        ]

        # Call the function under test
        upsert_project(Project(name="new_project", domain="new_domain"))

        # Assert that the mock functions were called correctly
        mock_get_projects.assert_called_once()
        mock_write_projects.assert_called_once_with(
            [
                Project(
                    name="project1",
                    description="description1",
                    domain="domain1",
                    upstream="upstream1",
                    services=[],
                ),
                Project(
                    name="project2",
                    description="description2",
                    domain="domain2",
                    upstream="upstream2",
                    services=[],
                ),
                Project(name="new_project", domain="new_domain"),
            ]
        )


if __name__ == "__main__":
    unittest.main()
