# Generated by CodiumAI
import os
import sys
import unittest
from unittest import TestCase, mock

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from lib.certs import get_certs

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))


class TestCodeUnderTest(TestCase):

    # Certbot command is run for each domain
    @mock.patch("os.environ", {"LE_EMAIL": "mail@example.com"})
    @mock.patch("lib.certs.get_domains", return_value=["example.com"])
    @mock.patch("subprocess.Popen", return_value=mock.Mock())
    @mock.patch("lib.certs.stream_output")
    def test_certbot_command_run_for_each_domain(
        self, mock_stream_output: mock.Mock, mock_popen: mock.Mock, _
    ):
        # Call the function under test
        get_certs()

        expected_command_calls = [
            mock.call(
                [
                    "docker",
                    "run",
                    "--rm",
                    "--name",
                    "certbot",
                    "-v",
                    "./data:/data",
                    "-v",
                    "./certs:/certs",
                    "certbot/certbot",
                    "certonly",
                    "-d",
                    "example.com",
                    "--webroot",
                    "--webroot-path=/data/certbot",
                    "--email",
                    "mail@example.com",
                    "--agree-tos",
                    "--no-eff-email",
                    "--non-interactive",
                    "--config-dir",
                    "/data/letsencrypt",
                    "--work-dir",
                    "/data/letsencrypt",
                    "--logs-dir",
                    "/data/letsencrypt",
                    "--post-hook",
                    "mkdir -p /certs/example.com && \
                cp -L /data/letsencrypt/live/example.com/fullchain.pem /certs/example.com/fullchain.pem && \
                cp -L /data/letsencrypt/live/example.com/privkey.pem /certs/example.com/privkey.pem && \
                chown -R 101:101 /certs/example.com && touch /data/changed && chmod a+wr /data/changed",
                ],
                stdout=-1,
            ),
        ]

        mock_popen.assert_has_calls(expected_command_calls)
        mock_stream_output.assert_called_once()

    # Certificates are updated if they have changed
    @mock.patch("subprocess.Popen")
    @mock.patch("lib.certs.get_domains")
    @mock.patch("lib.certs.stream_output")
    @mock.patch("os.path.isfile")
    @mock.patch("os.remove")
    def test_certificates_updated_if_changed(
        self, mock_remove, mock_isfile, _, mock_get_domains, mock_popen
    ):
        mock_get_domains.return_value = ["example.com"]
        mock_process = mock.Mock()
        mock_popen.return_value = mock_process
        mock_isfile.return_value = True

        # Call the function under test
        result = get_certs()

        mock_remove.assert_called_once_with("./data/changed")
        self.assertTrue(result)

    # No domains are passed to certbot
    @mock.patch("subprocess.Popen")
    @mock.patch("lib.certs.get_domains")
    @mock.patch("lib.certs.stream_output")
    @mock.patch("os.remove")
    def test_no_domains_passed_to_certbot(
        self, mock_remove, _, mock_get_domains, mock_popen
    ):
        mock_get_domains.return_value = []

        # Call the function under test
        result = get_certs()

        mock_popen.assert_not_called()
        mock_remove.assert_not_called()
        self.assertFalse(result)

    # LE_EMAIL environment variable is not set
    @mock.patch("os.environ", {})
    def test_le_email_env_variable_not_set(self):

        # Call the function under test
        with self.assertRaises(ValueError) as context:
            get_certs()

        self.assertEqual(
            str(context.exception), "LE_EMAIL environment variable is not set"
        )


if __name__ == "__main__":
    unittest.main()
